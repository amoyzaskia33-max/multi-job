import inspect
import json
import os
import re
from typing import Any, Dict, List, Optional, Set, Tuple

from pydantic import BaseModel, Field

from app.core.integration_configs import get_integration_account, list_integration_accounts
from app.core.models import JobSpec, RetryPolicy, Schedule
from app.services.api.planner import PlannerJob, PlannerRequest, PlannerResponse, build_plan_from_prompt


class PlannerAiRequest(PlannerRequest):
    force_rule_based: bool = False
    model_id: Optional[str] = None
    ai_provider: str = "auto"
    ai_account_id: str = "default"
    # Legacy field kept for backward compatibility with existing clients.
    openai_account_id: str = "default"
    max_steps: int = Field(default=4, ge=1, le=12)


class PlannerAiCredentials(BaseModel):
    provider: str
    account_id: str
    model_id: str
    api_key: str = ""
    api_base: Optional[str] = None


ALLOWED_JOB_TYPES: Set[str] = {
    "monitor.channel",
    "report.daily",
    "backup.export",
    "agent.workflow",
}

DEFAULT_TIMEOUT_MS: Dict[str, int] = {
    "monitor.channel": 15000,
    "report.daily": 45000,
    "backup.export": 120000,
    "agent.workflow": 90000,
}

DEFAULT_RETRY: Dict[str, RetryPolicy] = {
    "monitor.channel": RetryPolicy(max_retry=5, backoff_sec=[1, 2, 5, 10, 30]),
    "report.daily": RetryPolicy(max_retry=3, backoff_sec=[5, 10, 30]),
    "backup.export": RetryPolicy(max_retry=2, backoff_sec=[10, 30]),
    "agent.workflow": RetryPolicy(max_retry=1, backoff_sec=[2, 5]),
}

PROVIDER_CHAIN_DEFAULT: List[str] = ["openai", "ollama"]
DEFAULT_MODEL_PER_PROVIDER: Dict[str, str] = {
    "openai": "openai/gpt-4o-mini",
    "ollama": "ollama/qwen3:8b",
}


def _normalisasi_teks(text: str) -> str:
    return " ".join(text.lower().strip().split())


def _buat_slug(value: str) -> str:
    slug = re.sub(r"[^a-zA-Z0-9_-]+", "-", value).strip("-").lower()
    return slug or "job"


def _pastikan_id_job_unik(base_id: str, used_ids: Set[str]) -> str:
    candidate = base_id
    suffix = 2
    while candidate in used_ids:
        candidate = f"{base_id}-{suffix}"
        suffix += 1
    used_ids.add(candidate)
    return candidate


def _hapus_duplikat(items: List[str]) -> List[str]:
    seen: Set[str] = set()
    output: List[str] = []
    for item in items:
        cleaned = item.strip()
        if not cleaned:
            continue
        if cleaned in seen:
            continue
        seen.add(cleaned)
        output.append(cleaned)
    return output


def _normalisasi_provider(provider: str) -> str:
    cleaned = str(provider or "").strip().lower()
    return cleaned or "auto"


def _normalisasi_model_id(provider: str, model_id: str) -> str:
    cleaned = str(model_id or "").strip()
    if not cleaned:
        return ""
    if "/" in cleaned:
        return cleaned
    if provider == "openai":
        return f"openai/{cleaned}"
    if provider == "ollama":
        return f"ollama/{cleaned}"
    return cleaned


def _ambil_base_url_dari_config(config: Any) -> str:
    if not isinstance(config, dict):
        return ""

    kandidat = [
        config.get("base_url"),
        config.get("api_base"),
        config.get("openai_base_url"),
    ]
    for value in kandidat:
        cleaned = str(value or "").strip()
        if cleaned:
            return cleaned
    return ""


def _akun_provider_siapsaji(provider: str, row: Optional[Dict[str, Any]]) -> bool:
    if not row or not isinstance(row, dict):
        return False
    if not bool(row.get("enabled", True)):
        return False
    if provider == "openai":
        return bool(str(row.get("secret") or "").strip())
    return True


def _ekstrak_teks_json(raw: Any) -> Optional[str]:
    if raw is None:
        return None

    if isinstance(raw, dict):
        return json.dumps(raw)

    text = str(raw).strip()
    if not text:
        return None

    if text.startswith("```"):
        text = re.sub(r"^```(?:json)?\s*", "", text, flags=re.IGNORECASE)
        text = re.sub(r"\s*```$", "", text)

    start = text.find("{")
    end = text.rfind("}")
    if start == -1 or end == -1 or end <= start:
        return None

    return text[start : end + 1]


def _bangun_prompt_smolagents(request: PlannerAiRequest) -> str:
    return (
        "Kamu adalah planner sistem job backend Python.\n"
        "Ubah prompt user menjadi rencana job terstruktur dalam JSON valid.\n"
        "Kembalikan HANYA JSON (tanpa markdown, tanpa penjelasan).\n"
        "Schema JSON:\n"
        "{\n"
        '  "summary": "string",\n'
        '  "assumptions": ["string"],\n'
        '  "warnings": ["string"],\n'
        '  "jobs": [\n'
        "    {\n"
        '      "job_id": "optional-string",\n'
        '      "type": "monitor.channel|report.daily|backup.export|agent.workflow",\n'
        '      "reason": "string",\n'
        '      "assumptions": ["string"],\n'
        '      "warnings": ["string"],\n'
        '      "schedule": {"interval_sec": 30} atau {"cron": "0 7 * * *"} atau null (agent.workflow),\n'
        '      "timeout_ms": 15000,\n'
        '      "retry_policy": {"max_retry": 3, "backoff_sec": [1,2,5]},\n'
        '      "inputs": {"channel":"telegram","account_id":"bot_a01"} atau {"prompt":"instruksi user"}\n'
        "    }\n"
        "  ]\n"
        "}\n\n"
        f"Prompt user: {request.prompt}\n"
        f"Timezone default: {request.timezone}\n"
        f"Default channel: {request.default_channel}\n"
        f"Default account_id: {request.default_account_id}\n\n"
        "Aturan:\n"
        "1) Gunakan hanya type job yang diizinkan.\n"
        "2) Jika data kurang, isi assumptions dan pakai default aman.\n"
        "3) ID job harus singkat, slug, dan unik.\n"
        "4) Untuk laporan/backup harian, prefer cron.\n"
    )


def _inisialisasi_model_litellm(
    model_class: Any,
    model_id: str,
    api_key: Optional[str],
    api_base: Optional[str] = None,
) -> Any:
    daftar_percobaan: List[Dict[str, Any]] = []

    daftar_nama_model = ["model_id", "model"]
    daftar_nama_base = ["api_base", "base_url"]

    for nama_model in daftar_nama_model:
        kwargs_dasar: Dict[str, Any] = {nama_model: model_id}
        daftar_percobaan.append(dict(kwargs_dasar))
        if api_key:
            daftar_percobaan.append({**kwargs_dasar, "api_key": api_key})

        if api_base:
            for nama_base in daftar_nama_base:
                daftar_percobaan.append({**kwargs_dasar, nama_base: api_base})
                if api_key:
                    daftar_percobaan.append({**kwargs_dasar, nama_base: api_base, "api_key": api_key})

    errors: List[str] = []
    sudah_dicoba: Set[str] = set()
    for kwargs in daftar_percobaan:
        clean_kwargs = {key: value for key, value in kwargs.items() if value is not None}
        jejak = json.dumps(clean_kwargs, sort_keys=True)
        if jejak in sudah_dicoba:
            continue
        sudah_dicoba.add(jejak)
        try:
            return model_class(**clean_kwargs)
        except Exception as exc:
            errors.append(str(exc))

    raise RuntimeError("Gagal inisialisasi LiteLLMModel: " + " | ".join(errors))


def _buat_code_agent(code_agent_class: Any, model: Any, max_steps: int) -> Any:
    kwargs: Dict[str, Any] = {"tools": [], "model": model}

    try:
        signature = inspect.signature(code_agent_class)
        if "add_base_tools" in signature.parameters:
            kwargs["add_base_tools"] = False
        if "max_steps" in signature.parameters:
            kwargs["max_steps"] = max_steps
    except Exception:
        pass

    return code_agent_class(**kwargs)


async def _pilih_akun_openai_dashboard(account_id: str) -> Tuple[Optional[Dict[str, Any]], List[str]]:
    return await _pilih_akun_provider_dashboard("openai", account_id)


async def _pilih_akun_provider_dashboard(provider: str, account_id: str) -> Tuple[Optional[Dict[str, Any]], List[str]]:
    warnings: List[str] = []
    normalized_provider = _normalisasi_provider(provider)
    target_id = str(account_id or "default").strip() or "default"

    try:
        pilihan = await get_integration_account(normalized_provider, target_id, include_secret=True)
    except Exception:
        pilihan = None

    if _akun_provider_siapsaji(normalized_provider, pilihan):
        return pilihan, warnings

    try:
        daftar = await list_integration_accounts(provider=normalized_provider, include_secret=True)
    except Exception:
        daftar = []

    kandidat_akun: List[Dict[str, Any]] = []
    for row in daftar:
        if _akun_provider_siapsaji(normalized_provider, row):
            kandidat_akun.append(row)

    kandidat_akun.sort(key=lambda row: str(row.get("account_id") or ""))
    if kandidat_akun:
        kandidat = kandidat_akun[0]
        kandidat_id = str(kandidat.get("account_id") or "default").strip() or "default"
        if kandidat_id != target_id:
            warnings.append(
                f"Akun {normalized_provider}/{target_id} belum siap. Planner AI memakai akun {normalized_provider}/{kandidat_id}."
            )
        return kandidat, warnings

    return None, warnings


async def resolve_planner_ai_credential_candidates(
    request: PlannerAiRequest,
) -> Tuple[List[PlannerAiCredentials], List[str]]:
    warnings: List[str] = []
    daftar_kandidat: List[PlannerAiCredentials] = []

    provider_request = _normalisasi_provider(request.ai_provider)
    account_target = str(request.ai_account_id or "").strip() or str(request.openai_account_id or "default").strip() or "default"
    model_request = str(request.model_id or "").strip()

    provider_chain = [provider_request] if provider_request != "auto" else list(PROVIDER_CHAIN_DEFAULT)

    for provider in provider_chain:
        butuh_warning = provider_request != "auto" or len(daftar_kandidat) == 0
        akun, warning_akun = await _pilih_akun_provider_dashboard(provider, account_target)
        if butuh_warning:
            warnings.extend(warning_akun)

        if akun:
            config = akun.get("config", {})
            model_dari_config = str(config.get("model_id") or "").strip() if isinstance(config, dict) else ""
            model_id = _normalisasi_model_id(provider, model_request or model_dari_config or DEFAULT_MODEL_PER_PROVIDER.get(provider, ""))
            api_key = str(akun.get("secret") or "").strip()
            api_base = _ambil_base_url_dari_config(config)

            if provider == "ollama":
                if not api_base:
                    api_base = str(os.getenv("OLLAMA_BASE_URL") or "http://localhost:11434").strip()
                if not api_key:
                    api_key = str(os.getenv("OLLAMA_API_KEY") or "ollama").strip()

            if model_id:
                daftar_kandidat.append(
                    PlannerAiCredentials(
                        provider=provider,
                        account_id=str(akun.get("account_id") or account_target or "default"),
                        model_id=model_id,
                        api_key=api_key,
                        api_base=api_base or None,
                    )
                )
            continue

        if provider == "openai":
            env_api_key = str(os.getenv("OPENAI_API_KEY") or "").strip()
            if env_api_key:
                model_id = _normalisasi_model_id(
                    "openai",
                    model_request or str(os.getenv("PLANNER_AI_MODEL") or DEFAULT_MODEL_PER_PROVIDER["openai"]).strip(),
                )
                daftar_kandidat.append(
                    PlannerAiCredentials(
                        provider="openai",
                        account_id="env",
                        model_id=model_id,
                        api_key=env_api_key,
                        api_base=str(os.getenv("OPENAI_BASE_URL") or "").strip() or None,
                    )
                )
                if butuh_warning:
                    warnings.append("Token OpenAI diambil dari environment (OPENAI_API_KEY).")
            else:
                if butuh_warning:
                    warnings.append("Akun OpenAI belum siap dan OPENAI_API_KEY belum diisi.")

        if provider == "ollama":
            model_id = _normalisasi_model_id(
                "ollama",
                model_request or str(os.getenv("OLLAMA_MODEL") or DEFAULT_MODEL_PER_PROVIDER["ollama"]).strip(),
            )
            api_base = str(os.getenv("OLLAMA_BASE_URL") or "http://localhost:11434").strip()
            api_key = str(os.getenv("OLLAMA_API_KEY") or "ollama").strip()
            daftar_kandidat.append(
                PlannerAiCredentials(
                    provider="ollama",
                    account_id="local",
                    model_id=model_id,
                    api_key=api_key,
                    api_base=api_base,
                )
            )
            if butuh_warning:
                warnings.append("Akun Ollama di dashboard belum siap, memakai konfigurasi lokal default.")

    kandidat_final: List[PlannerAiCredentials] = []
    jejak: Set[str] = set()
    for row in daftar_kandidat:
        signature = f"{row.provider}|{row.account_id}|{row.model_id}|{row.api_base or ''}"
        if signature in jejak:
            continue
        jejak.add(signature)
        kandidat_final.append(row)

    return kandidat_final, _hapus_duplikat(warnings)


async def resolve_planner_ai_credentials(
    request: PlannerAiRequest,
) -> Tuple[str, str, List[str]]:
    kandidat, warnings = await resolve_planner_ai_credential_candidates(request)
    if kandidat:
        return kandidat[0].model_id, kandidat[0].api_key, warnings

    model_id = str(request.model_id or "").strip() or str(os.getenv("PLANNER_AI_MODEL") or DEFAULT_MODEL_PER_PROVIDER["openai"]).strip()
    if not model_id:
        model_id = DEFAULT_MODEL_PER_PROVIDER["openai"]
    model_id = _normalisasi_model_id("openai", model_id)
    api_key = str(os.getenv("OPENAI_API_KEY") or "").strip()
    return model_id, api_key, _hapus_duplikat(warnings)


def _jalankan_smolagents(
    request: PlannerAiRequest,
    *,
    model_id_override: Optional[str] = None,
    api_key_override: Optional[str] = None,
    api_base_override: Optional[str] = None,
) -> Tuple[Optional[Dict[str, Any]], List[str]]:
    warnings: List[str] = []

    try:
        import smolagents  # type: ignore
    except Exception:
        return None, ["smolagents belum terpasang. Gunakan: pip install smolagents litellm."]

    code_agent_class = getattr(smolagents, "CodeAgent", None)
    model_class = getattr(smolagents, "LiteLLMModel", None)

    if code_agent_class is None or model_class is None:
        return None, ["Versi smolagents tidak menyediakan CodeAgent/LiteLLMModel."]

    model_id = str(
        model_id_override
        or request.model_id
        or os.getenv("PLANNER_AI_MODEL", DEFAULT_MODEL_PER_PROVIDER["openai"])
    ).strip()
    api_key = str(api_key_override or os.getenv("OPENAI_API_KEY") or "").strip()
    api_base = str(api_base_override or os.getenv("PLANNER_AI_BASE_URL") or "").strip()

    if model_id.startswith("openai/") and not api_key:
        return None, [
            "Token OpenAI belum tersedia. Isi Setelan > Akun Integrasi (openai/default) "
            "atau set OPENAI_API_KEY. Planner AI fallback ke rule-based."
        ]

    if model_id.startswith("ollama/") and not api_base:
        api_base = "http://localhost:11434"

    try:
        model = _inisialisasi_model_litellm(
            model_class,
            model_id=model_id,
            api_key=api_key,
            api_base=api_base or None,
        )
    except Exception as exc:
        return None, [f"Gagal inisialisasi model AI: {exc}"]

    try:
        agent = _buat_code_agent(code_agent_class, model=model, max_steps=request.max_steps)
        raw_output = agent.run(_bangun_prompt_smolagents(request))
    except Exception as exc:
        return None, [f"Eksekusi smolagents gagal: {exc}"]

    json_text = _ekstrak_teks_json(raw_output)
    if not json_text:
        return None, ["Output AI tidak berbentuk JSON yang valid."]

    try:
        payload = json.loads(json_text)
    except Exception as exc:
        return None, [f"Gagal parse JSON dari output AI: {exc}"]

    if not isinstance(payload, dict):
        return None, ["Payload AI bukan object JSON."]

    return payload, warnings


def _paksa_jadwal(raw: Any, warnings: List[str], index: int) -> Optional[Schedule]:
    if not isinstance(raw, dict):
        warnings.append(f"Job #{index + 1}: schedule tidak valid, pakai default.")
        return None

    cron = raw.get("cron")
    interval_sec = raw.get("interval_sec")
    if cron is None and interval_sec is None:
        warnings.append(f"Job #{index + 1}: schedule kosong, pakai default.")
        return None

    if interval_sec is not None:
        try:
            interval_sec = int(interval_sec)
        except Exception:
            warnings.append(f"Job #{index + 1}: interval_sec tidak valid, diabaikan.")
            interval_sec = None

    try:
        return Schedule(cron=cron, interval_sec=interval_sec)
    except Exception:
        warnings.append(f"Job #{index + 1}: format schedule tidak valid, pakai default.")
        return None


def _jadwal_default_per_job(job_type: str) -> Optional[Schedule]:
    if job_type == "monitor.channel":
        return Schedule(interval_sec=30)
    if job_type == "report.daily":
        return Schedule(cron="0 7 * * *")
    if job_type == "agent.workflow":
        return None
    return Schedule(cron="0 2 * * *")


def _retry_default(job_type: str) -> RetryPolicy:
    source = DEFAULT_RETRY[job_type]
    return RetryPolicy(max_retry=source.max_retry, backoff_sec=list(source.backoff_sec))


def build_plan_from_ai_payload(request: PlannerAiRequest, payload: Dict[str, Any]) -> PlannerResponse:
    normalized_prompt = _normalisasi_teks(request.prompt)
    assumptions: List[str] = []
    warnings: List[str] = []
    jobs: List[PlannerJob] = []
    used_ids: Set[str] = set()

    assumptions.extend(payload.get("assumptions", []) if isinstance(payload.get("assumptions"), list) else [])
    warnings.extend(payload.get("warnings", []) if isinstance(payload.get("warnings"), list) else [])

    raw_jobs = payload.get("jobs")
    if not isinstance(raw_jobs, list):
        warnings.append("Payload AI tidak memiliki daftar jobs yang valid.")
        raw_jobs = []

    for index, item in enumerate(raw_jobs):
        if not isinstance(item, dict):
            warnings.append(f"Item jobs #{index + 1} bukan object, dilewati.")
            continue

        job_type = str(item.get("type") or "").strip()
        if job_type not in ALLOWED_JOB_TYPES:
            warnings.append(f"Job #{index + 1}: type '{job_type}' tidak didukung, dilewati.")
            continue

        reason = str(item.get("reason") or f"Dibuat oleh planner AI untuk type {job_type}.")
        item_assumptions = item.get("assumptions", []) if isinstance(item.get("assumptions"), list) else []
        item_warnings = item.get("warnings", []) if isinstance(item.get("warnings"), list) else []

        if job_type == "agent.workflow":
            schedule = None
        else:
            schedule = _paksa_jadwal(item.get("schedule"), warnings, index) or _jadwal_default_per_job(job_type)

        retry_raw = item.get("retry_policy")
        retry_policy: RetryPolicy
        if isinstance(retry_raw, dict):
            try:
                retry_policy = RetryPolicy(
                    max_retry=int(retry_raw.get("max_retry", DEFAULT_RETRY[job_type].max_retry)),
                    backoff_sec=list(retry_raw.get("backoff_sec", DEFAULT_RETRY[job_type].backoff_sec)),
                )
            except Exception:
                retry_policy = _retry_default(job_type)
                warnings.append(f"Job #{index + 1}: retry_policy tidak valid, pakai default.")
        else:
            retry_policy = _retry_default(job_type)

        timeout_ms = item.get("timeout_ms", DEFAULT_TIMEOUT_MS[job_type])
        try:
            timeout_ms = int(timeout_ms)
        except Exception:
            timeout_ms = DEFAULT_TIMEOUT_MS[job_type]
            warnings.append(f"Job #{index + 1}: timeout_ms tidak valid, pakai default.")

        inputs = item.get("inputs", {})
        if not isinstance(inputs, dict):
            inputs = {}
            warnings.append(f"Job #{index + 1}: inputs tidak valid, pakai object kosong.")

        if job_type == "monitor.channel":
            inputs.setdefault("channel", request.default_channel)
            inputs.setdefault("account_id", request.default_account_id)
        if job_type == "agent.workflow":
            inputs.setdefault("prompt", request.prompt)
            inputs.setdefault("timezone", request.timezone)
            inputs.setdefault("default_channel", request.default_channel)
            inputs.setdefault("default_account_id", request.default_account_id)
        if job_type in {"report.daily", "backup.export"}:
            inputs.setdefault("timezone", request.timezone)
        inputs.setdefault("source", "planner_ai")

        base_id = str(item.get("job_id") or _buat_slug(f"{job_type}-{index + 1}"))
        job_id = _pastikan_id_job_unik(_buat_slug(base_id), used_ids)

        try:
            job_spec = JobSpec(
                job_id=job_id,
                type=job_type,
                schedule=schedule,
                timeout_ms=timeout_ms,
                retry_policy=retry_policy,
                inputs=inputs,
            )
        except Exception as exc:
            warnings.append(f"Job #{index + 1}: gagal validasi JobSpec ({exc}), dilewati.")
            continue

        jobs.append(
            PlannerJob(
                reason=reason,
                assumptions=item_assumptions,
                warnings=item_warnings,
                job_spec=job_spec,
            )
        )

    for job in jobs:
        assumptions.extend(job.assumptions)
        warnings.extend(job.warnings)

    assumptions = _hapus_duplikat(assumptions)
    warnings = _hapus_duplikat(warnings)

    summary = str(payload.get("summary") or f"Planner AI menghasilkan {len(jobs)} rencana tugas.")
    if not jobs:
        summary = "Planner AI belum menghasilkan job valid."

    return PlannerResponse(
        prompt=request.prompt,
        normalized_prompt=normalized_prompt,
        summary=summary,
        planner_source="smolagents",
        assumptions=assumptions,
        warnings=warnings,
        jobs=jobs,
    )


def build_plan_with_ai(
    request: PlannerAiRequest,
    *,
    model_id_override: Optional[str] = None,
    api_key_override: Optional[str] = None,
    api_base_override: Optional[str] = None,
    pre_warnings: Optional[List[str]] = None,
) -> PlannerResponse:
    fallback_plan = build_plan_from_prompt(request)
    warning_awal = _hapus_duplikat(list(pre_warnings or []))

    if request.force_rule_based:
        fallback_plan.warnings = _hapus_duplikat(
            [*fallback_plan.warnings, *warning_awal, "force_rule_based aktif: planner AI dilewati."]
        )
        return fallback_plan

    payload, ai_warnings = _jalankan_smolagents(
        request,
        model_id_override=model_id_override,
        api_key_override=api_key_override,
        api_base_override=api_base_override,
    )
    gabung_warning_ai = _hapus_duplikat([*warning_awal, *ai_warnings])
    if payload is None:
        fallback_plan.warnings = _hapus_duplikat(
            [
                *fallback_plan.warnings,
                *gabung_warning_ai,
                "Planner AI gagal dipakai. Sistem otomatis memakai planner rule-based.",
            ]
        )
        return fallback_plan

    ai_plan = build_plan_from_ai_payload(request, payload)
    if not ai_plan.jobs:
        fallback_plan.warnings = _hapus_duplikat(
            [
                *fallback_plan.warnings,
                *gabung_warning_ai,
                *ai_plan.warnings,
                "Planner AI tidak menghasilkan job valid. Sistem memakai planner rule-based.",
            ]
        )
        return fallback_plan

    ai_plan.warnings = _hapus_duplikat([*ai_plan.warnings, *gabung_warning_ai])
    return ai_plan


async def build_plan_with_ai_dari_dashboard(request: PlannerAiRequest) -> PlannerResponse:
    kandidat, warnings_awal = await resolve_planner_ai_credential_candidates(request)
    fallback_plan = build_plan_from_prompt(request)

    if request.force_rule_based:
        fallback_plan.warnings = _hapus_duplikat(
            [*fallback_plan.warnings, *warnings_awal, "force_rule_based aktif: planner AI dilewati."]
        )
        return fallback_plan

    warning_terkumpul = list(warnings_awal)
    if not kandidat:
        fallback_plan.warnings = _hapus_duplikat(
            [
                *fallback_plan.warnings,
                *warning_terkumpul,
                "Planner AI belum menemukan provider yang siap. Sistem memakai planner rule-based.",
            ]
        )
        return fallback_plan

    for index, kredensial in enumerate(kandidat, start=1):
        warning_konteks = _hapus_duplikat(
            [
                *warning_terkumpul,
                f"Mencoba planner AI lewat {kredensial.provider}/{kredensial.account_id} (percobaan {index}/{len(kandidat)}).",
            ]
        )

        payload, warnings_ai = _jalankan_smolagents(
            request,
            model_id_override=kredensial.model_id,
            api_key_override=kredensial.api_key,
            api_base_override=kredensial.api_base,
        )

        if payload is None:
            warning_terkumpul = _hapus_duplikat(
                [*warning_konteks, *warnings_ai, f"Planner AI gagal di {kredensial.provider}/{kredensial.account_id}."]
            )
            continue

        ai_plan = build_plan_from_ai_payload(request, payload)
        if ai_plan.jobs:
            ai_plan.warnings = _hapus_duplikat([*ai_plan.warnings, *warning_konteks, *warnings_ai])
            return ai_plan

        warning_terkumpul = _hapus_duplikat(
            [
                *warning_konteks,
                *warnings_ai,
                *ai_plan.warnings,
                f"Planner AI di {kredensial.provider}/{kredensial.account_id} tidak menghasilkan job valid.",
            ]
        )

    fallback_plan.warnings = _hapus_duplikat(
        [
            *fallback_plan.warnings,
            *warning_terkumpul,
            "Planner AI gagal di semua provider yang tersedia. Sistem memakai planner rule-based.",
        ]
    )
    return fallback_plan
